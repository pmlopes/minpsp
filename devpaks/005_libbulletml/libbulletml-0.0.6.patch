diff -Naur src/boost/config/compiler/gcc.hpp src/boost/config/compiler/gcc.hpp
--- src/boost/config/compiler/gcc.hpp	2003-01-30 19:13:55.000000000 +0100
+++ src/boost/config/compiler/gcc.hpp	2010-11-25 09:47:47.137629000 +0100
@@ -28,6 +28,10 @@
 #     define BOOST_NO_OPERATORS_IN_NAMESPACE
 #   endif
 
+#ifndef __EXCEPTIONS
+# define BOOST_NO_EXCEPTIONS
+#endif
+
 //
 // Threading support: Turn this on unconditionally here (except for
 // MinGW, where we can know for sure). It will get turned off again
@@ -58,11 +62,13 @@
 #  error "Compiler not configured - please reconfigure"
 #endif
 //
-// last known and checked version is 3.2:
-#if (__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ > 2))
+// last known and checked version is 4.3:
+#if (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 3))
 #  if defined(BOOST_ASSERT_CONFIG)
 #     error "Unknown compiler version - please run the configure tests and report the results"
 #  else
-#     warning "Unknown compiler version - please run the configure tests and report the results"
+// we don't emit warnings here anymore since there are no defect macros defined for
+// gcc post 3.4, so any failures are gcc regressions...
+//#     warning "Unknown compiler version - please run the configure tests and report the results"
 #  endif
 #endif
diff -Naur src/bulletmlcommon.h src/bulletmlcommon.h
--- src/bulletmlcommon.h	2003-09-06 19:18:42.000000000 +0200
+++ src/bulletmlcommon.h	2010-11-24 17:08:35.269432998 +0100
@@ -7,5 +7,11 @@
 # define DECLSPEC
 #endif
 
+#ifndef __EXCEPTIONS
+#include <boost/throw_exception.hpp>
+
+inline void boost::throw_exception(std::exception const &) {}
+#endif
+
 #endif // ! bulletmlcommon_h_
 
diff -Naur src/bulletmlerror.h src/bulletmlerror.h
--- src/bulletmlerror.h	2003-09-06 19:18:42.000000000 +0200
+++ src/bulletmlerror.h	2010-11-24 17:10:03.859432999 +0100
@@ -11,6 +11,7 @@
 	DECLSPEC BulletMLError(const std::string& msg)
 		: std::runtime_error(msg) {}
 
+#ifdef __EXCEPTIONS
 	DECLSPEC static void doAssert(const char* str) {
 		throw BulletMLError(str);
 	}
@@ -23,6 +24,16 @@
 	DECLSPEC static void doAssert(bool t, const std::string& str) {
 		if (!t) throw BulletMLError(str);
 	}
+#else
+	DECLSPEC static void doAssert(const char*) {
+	}
+	DECLSPEC static void doAssert(const std::string&) {
+	}
+	DECLSPEC static void doAssert(bool, const char*) {
+	}
+	DECLSPEC static void doAssert(bool, const std::string&) {
+	}
+#endif // __EXCEPTIONS
 
 };
 
diff -Naur src/bulletmlparser-tinyxml.cpp src/bulletmlparser-tinyxml.cpp
--- src/bulletmlparser-tinyxml.cpp	2003-09-06 19:18:41.000000000 +0200
+++ src/bulletmlparser-tinyxml.cpp	2010-11-24 17:11:36.239433001 +0100
@@ -58,7 +58,9 @@
 
 void BulletMLParserTinyXML::parseImpl(TiXmlDocument& doc) {
 	if (doc.Error()) {
+#ifdef __EXCEPTIONS
 		throw BulletMLError(doc.Value() + ": " + doc.ErrorDesc());
+#endif
 	}
 
     TiXmlNode* node;
diff -Naur src/bulletmlrunner.h src/bulletmlrunner.h
--- src/bulletmlrunner.h	2003-09-06 19:18:42.000000000 +0200
+++ src/bulletmlrunner.h	2010-11-24 17:14:28.079432998 +0100
@@ -17,7 +17,7 @@
 class BulletMLNode;
 class BulletMLRunnerImpl;
 
-typedef std::vector<double> BulletMLParameter;
+typedef std::vector<float> BulletMLParameter;
 
 /// BulletMLRunner が状態伝達に使用するクラス
 class BulletMLState {
@@ -69,23 +69,23 @@
 	/**
 	 * @return 角度を度単位で、上方向 0 で時計周りで返す
 	 */
-	DECLSPEC virtual double getBulletDirection() =0;
+	DECLSPEC virtual float getBulletDirection() =0;
 	/// この弾から自機を狙う角度を求める
 	/**
 	 * @return 角度を度単位で、上方向 0 で時計周りで返す
 	 */
-	DECLSPEC virtual double getAimDirection() =0;
+	DECLSPEC virtual float getAimDirection() =0;
 	/// この弾の速度を求める
-	DECLSPEC virtual double getBulletSpeed() =0;
+	DECLSPEC virtual float getBulletSpeed() =0;
 	/// デフォルトの速度を求める
-	DECLSPEC virtual double getDefaultSpeed() =0;
+	DECLSPEC virtual float getDefaultSpeed() =0;
 	/// ランクを求める
 	/**
 	 * @return 0 から 1 までの実数
 	 */
-	DECLSPEC virtual double getRank() =0;
+	DECLSPEC virtual float getRank() =0;
 	/// action を持たない弾を作る
-	DECLSPEC virtual void createSimpleBullet(double direction, double speed) =0;
+	DECLSPEC virtual void createSimpleBullet(float direction, float speed) =0;
 	/// action を持つ弾を作る
 	/**
 	 * @param state
@@ -93,7 +93,7 @@
 	 * もし渡さないのであれば、delete で解放しなければならない。
 	 */
 	DECLSPEC virtual void createBullet(BulletMLState* state,
-									   double direction, double speed) =0;
+									   float direction, float speed) =0;
 	/// 弾の基準となるターンの値を返す、通常はフレーム数
 	/**
 	 * @return
@@ -110,33 +110,33 @@
 	// ----- 必要があれば実装する関数群の始まり -----
    	//@{
 	/// 弾の方向を指定した方向に変更する
-	DECLSPEC virtual void doChangeDirection(double) {}
+	DECLSPEC virtual void doChangeDirection(float) {}
 	/// 弾の速度を指定した値に変更する
-	DECLSPEC virtual void doChangeSpeed(double) {}
+	DECLSPEC virtual void doChangeSpeed(float) {}
 	/// accel に対するインターフェイス
 	/**
 	 * @todo
 	 * horizontal, vertical の type は未実装です。
 	 * どれも absolute になってしまいます。
 	 */
-	DECLSPEC virtual void doAccelX(double) {}
+	DECLSPEC virtual void doAccelX(float) {}
 	/// accel に対するインターフェイス
 	/**
 	 * @todo
 	 * horizontal, vertical の type は未実装です。
 	 * どれも absolute になってしまいます。
 	 */
-	DECLSPEC virtual void doAccelY(double) {}
+	DECLSPEC virtual void doAccelY(float) {}
 	/// 弾の速さの X 方向成分を返します
 	/**
 	 * accel を使う場合はオーバーライドして下さい
  	 */
-	DECLSPEC virtual double getBulletSpeedX() { return 0; }
+	DECLSPEC virtual float getBulletSpeedX() { return 0; }
 	/// 弾の速さの Y 方向成分を返します
 	/**
 	 * accel を使う場合はオーバーライドして下さい
  	 */
-	DECLSPEC virtual double getBulletSpeedY() { return 0; }
+	DECLSPEC virtual float getBulletSpeedY() { return 0; }
     //@}
 	// ----- 必要があれば実装する関数群の終わり -----
 
@@ -144,7 +144,7 @@
 	/**
 	 * 見てのとおり、デフォルトでは std::rand が用いられます。
 	 */
-	DECLSPEC virtual double getRand() { return (double)rand() / RAND_MAX; }
+	DECLSPEC virtual float getRand() { return (float)rand() / RAND_MAX; }
 
 private:
 	/// BulletMLRunnerImpl をオーバーライドする場合、これもオーバーライドする
diff -Naur src/bulletmlrunnerimpl.cpp src/bulletmlrunnerimpl.cpp
--- src/bulletmlrunnerimpl.cpp	2004-04-15 08:03:26.000000000 +0200
+++ src/bulletmlrunnerimpl.cpp	2010-11-24 17:16:19.219433001 +0100
@@ -25,9 +25,9 @@
 	&BulletMLRunnerImpl::runVanish
 };
 
-double BulletMLRunnerImpl::getDirection(BulletMLNode* dirNode,
+float BulletMLRunnerImpl::getDirection(BulletMLNode* dirNode,
                                         bool prevChange) {
-    double dir;
+    float dir;
 
     bool isDefault = true;
     dir = getNumberContents(dirNode);
@@ -69,8 +69,8 @@
     return dir;
 }
 
-double BulletMLRunnerImpl::getSpeed(BulletMLNode* spdNode) {
-    double spd;
+float BulletMLRunnerImpl::getSpeed(BulletMLNode* spdNode) {
+    float spd;
 
     spd = getNumberContents(spdNode);
     if (spdNode->getType() != BulletMLNode::none) {
@@ -126,7 +126,7 @@
 	}
 }
 
-double BulletMLRunnerImpl::getNumberContents(const BulletMLNode* node) {
+float BulletMLRunnerImpl::getNumberContents(const BulletMLNode* node) {
     assert(node);
 
 	Variables::rank = runner_->getRank();
@@ -403,7 +403,7 @@
 	BulletMLNode* dirNode = act_->getChild(BulletMLNode::direction);
 	BulletMLNode::Type type = dirNode->getType();
 
-	double dir;
+	float dir;
 	if (type != BulletMLNode::sequence) dir = getDirection(dirNode, false);
 	else dir = getNumberContents(dirNode);
 
@@ -418,10 +418,10 @@
 	BulletMLNode* spdNode = act_->getChild(BulletMLNode::speed);
 	BulletMLNode::Type type = spdNode->getType();
 
-	double spd;
+	float spd;
 	if (type != BulletMLNode::sequence) spd = getSpeed(spdNode);
 	else {
-		spd = getNumberContents(spdNode) * (double)term
+		spd = getNumberContents(spdNode) * (float)term
 			+ runner_->getBulletSpeed();
 	}
 	
@@ -453,50 +453,50 @@
 	act_ = 0;
 }
 
-void BulletMLRunnerImpl::calcChangeDirection(double direction, int term,
+void BulletMLRunnerImpl::calcChangeDirection(float direction, int term,
 											 bool seq)
 {
 	int finalTurn = actTurn_ + term;
 
-	double dirFirst = runner_->getBulletDirection();
+	float dirFirst = runner_->getBulletDirection();
 
 	if (seq) {
-		auto_ptr_copy(changeDir_, new LinearFunc<int, double>
+		auto_ptr_copy(changeDir_, new LinearFunc<int, float>
 					  (actTurn_, finalTurn,
 					   dirFirst, dirFirst + direction * term));
 	}
 	else {
-		double dirSpace;
+		float dirSpace;
 
 		// ちゃんと近い方を回っていくのは結構難しいね
-		double dirSpace1 = direction - dirFirst;
-		double dirSpace2;
+		float dirSpace1 = direction - dirFirst;
+		float dirSpace2;
 		if (dirSpace1 > 0) dirSpace2 = dirSpace1 - 360;
 		else dirSpace2 = dirSpace1 + 360;
 		if (abs(dirSpace1) < abs(dirSpace2)) dirSpace = dirSpace1;
 		else dirSpace = dirSpace2;
 
-		auto_ptr_copy(changeDir_, new LinearFunc<int, double>
+		auto_ptr_copy(changeDir_, new LinearFunc<int, float>
 					  (actTurn_, finalTurn, dirFirst, dirFirst + dirSpace));
 	}
 }
 
-void BulletMLRunnerImpl::calcChangeSpeed(double speed, int term) {
+void BulletMLRunnerImpl::calcChangeSpeed(float speed, int term) {
 	int finalTurn = actTurn_ + term;
 
-	double spdFirst = runner_->getBulletSpeed();
+	float spdFirst = runner_->getBulletSpeed();
 
-	auto_ptr_copy(changeSpeed_, new LinearFunc<int, double>
+	auto_ptr_copy(changeSpeed_, new LinearFunc<int, float>
 				  (actTurn_, finalTurn, spdFirst, speed));
 }
 
-void BulletMLRunnerImpl::calcAccelY(double horizontal, int term,
+void BulletMLRunnerImpl::calcAccelY(float horizontal, int term,
 									BulletMLNode::Type type)
 {
 	int finalTurn = actTurn_ + term;
 
-	double firstSpd = runner_->getBulletSpeedY();
-	double finalSpd;
+	float firstSpd = runner_->getBulletSpeedY();
+	float finalSpd;
 
 	if (type == BulletMLNode::sequence) {
 		finalSpd = firstSpd + horizontal * term;
@@ -508,17 +508,17 @@
 		finalSpd = horizontal;
 	}
 
-	auto_ptr_copy(accely_, new LinearFunc<int, double>
+	auto_ptr_copy(accely_, new LinearFunc<int, float>
 				  (actTurn_, finalTurn, firstSpd, finalSpd));
 }
 
-void BulletMLRunnerImpl::calcAccelX(double vertical, int term,
+void BulletMLRunnerImpl::calcAccelX(float vertical, int term,
 									BulletMLNode::Type type)
 {
 	int finalTurn = actTurn_ + term;
 
-	double firstSpd = runner_->getBulletSpeedX();
-	double finalSpd;
+	float firstSpd = runner_->getBulletSpeedX();
+	float finalSpd;
 
 	if (type == BulletMLNode::sequence) {
 		finalSpd = firstSpd + vertical * term;
@@ -530,7 +530,7 @@
 		finalSpd = vertical;
 	}
 
-	auto_ptr_copy(accelx_ ,new LinearFunc<int, double>
+	auto_ptr_copy(accelx_ ,new LinearFunc<int, float>
 				  (actTurn_, finalTurn, firstSpd, finalSpd));
 }
 
diff -Naur src/bulletmlrunnerimpl.h src/bulletmlrunnerimpl.h
--- src/bulletmlrunnerimpl.h	2004-04-15 08:06:48.000000000 +0200
+++ src/bulletmlrunnerimpl.h	2010-11-24 17:17:14.159433000 +0100
@@ -12,7 +12,7 @@
 class BulletMLState;
 class BulletMLParser;
 
-typedef std::vector<double> BulletMLParameter;
+typedef std::vector<float> BulletMLParameter;
 
 template<class C_>
 class Validatable {
@@ -39,7 +39,7 @@
 };
 
 /// xyの初期値・終値から任意のxに対するyの線形補間を得るクラス
-template <class X_ = double, class Y_ = double>
+template <class X_ = float, class Y_ = float>
 class LinearFunc {
 public:
 	LinearFunc(const X_& firstX, const X_& lastX,
@@ -81,20 +81,20 @@
 
 public:
     /// 弾の方向変更を登録し、自前で各ターン変更する
-	virtual void calcChangeDirection(double direction, int term, bool seq);
+	virtual void calcChangeDirection(float direction, int term, bool seq);
     /// 弾の速度変更を登録し、自前で各ターン変更する
-	virtual void calcChangeSpeed(double speed, int term);
+	virtual void calcChangeSpeed(float speed, int term);
     /// 弾の加速を登録し、自前で各ターン変更する
 	/**
 	 * @todo horizontal, vertical の type は未実装です。
 	 */
-	virtual void calcAccelX(double vertical, int term,
+	virtual void calcAccelX(float vertical, int term,
 							BulletMLNode::Type type);
     /// 弾の加速を登録し、自前で各ターン変更する
 	/**
 	 * @todo horizontal, vertical の type は未実装です。
 	 */
-	virtual void calcAccelY(double horizontal, int term,
+	virtual void calcAccelY(float horizontal, int term,
 							BulletMLNode::Type type);
 
 protected:
@@ -133,20 +133,20 @@
 		dir_.disValidate();
     }
 
-    double getNumberContents(const BulletMLNode* node);
-    std::vector<double>* getParameters();
-    double getSpeed(BulletMLNode* spdNode);
-	double getDirection(BulletMLNode* dirNode, bool prevChange = true);
+    float getNumberContents(const BulletMLNode* node);
+    std::vector<float>* getParameters();
+    float getSpeed(BulletMLNode* spdNode);
+	float getDirection(BulletMLNode* dirNode, bool prevChange = true);
 
 private:
 private:
-    std::auto_ptr<LinearFunc<int, double> > changeDir_;
-    std::auto_ptr<LinearFunc<int, double> > changeSpeed_;
-    std::auto_ptr<LinearFunc<int, double> > accelx_;
-    std::auto_ptr<LinearFunc<int, double> > accely_;
+    std::auto_ptr<LinearFunc<int, float> > changeDir_;
+    std::auto_ptr<LinearFunc<int, float> > changeSpeed_;
+    std::auto_ptr<LinearFunc<int, float> > accelx_;
+    std::auto_ptr<LinearFunc<int, float> > accely_;
 
 protected:
-    Validatable<double> spd_, dir_, prevSpd_, prevDir_;
+    Validatable<float> spd_, dir_, prevSpd_, prevDir_;
 
     typedef BulletMLParameter Parameters;
     boost::shared_ptr<Parameters> parameters_;
diff -Naur src/bulletmltree.h src/bulletmltree.h
--- src/bulletmltree.h	2003-09-06 19:18:42.000000000 +0200
+++ src/bulletmltree.h	2010-11-25 09:33:30.107628994 +0100
@@ -18,7 +18,7 @@
 
 class BulletMLNode : public TreeNode<BulletMLNode> {
 public:
-	typedef Formula<double> Number;
+	typedef Formula<float> Number;
 	typedef enum { none, aim, absolute, relative, sequence, typeSize } Type;
 	typedef enum { bullet, action, fire, changeDirection, changeSpeed, accel,
 				   wait, repeat, bulletRef, actionRef, fireRef, vanish,
@@ -41,7 +41,7 @@
     DECLSPEC Name getName() const { return name_; }
 
     DECLSPEC void setValue(const std::string& val);
-    DECLSPEC double getValue() const { return val_->value(); }
+    DECLSPEC float getValue() const { return val_->value(); }
 
 	DECLSPEC void setType(const std::string& type) { type_ = string2type(type); }
 	DECLSPEC Type getType() const { return type_; }
diff -Naur src/calc.cpp src/calc.cpp
--- src/calc.cpp	2003-09-06 19:18:41.000000000 +0200
+++ src/calc.cpp	2010-11-25 09:49:22.077628997 +0100
@@ -1,22 +1,82 @@
 
-/*  A Bison parser, made from calc.yy
-    by GNU Bison version 1.28  */
+/* A Bison parser, made by GNU Bison 2.4.1.  */
 
-#define YYBISON 1  /* Identify Bison output.  */
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
 
-#define	NUM	257
-#define	RAND	258
-#define	RANK	259
-#define	PARAM	260
-#define	NEG	261
+/* Pure parsers.  */
+#define YYPURE 0
 
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
 #line 3 "calc.yy"
 
-typedef double NumType;
+typedef float NumType;
 
-#define YYSTYPE double
+#define YYSTYPE float
 #define YYERROR_VERBOSE
 
+#include <string.h>
+
 #include <cmath>
 #include <cctype>
 
@@ -43,983 +103,1595 @@
 	CalcFormula* formula;
 	std::vector<CalcFormula*> formulas;
 
-	CalcFormula* f(double d) { return formulas[(int)d]; }
+	CalcFormula* f(float d) { return formulas[(int)d]; }
 
 	int paramId;
 }
 
-#ifndef YYSTYPE
-#define YYSTYPE int
+
+
+/* Line 189 of yacc.c  */
+#line 115 "y.tab.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
 #endif
-#include <stdio.h>
 
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
 #endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NUM = 258,
+     RAND = 259,
+     RANK = 260,
+     PARAM = 261,
+     NEG = 262
+   };
 #endif
+/* Tokens.  */
+#define NUM 258
+#define RAND 259
+#define RANK 260
+#define PARAM 261
+#define NEG 262
 
 
 
-#define	YYFINAL		24
-#define	YYFLAG		-32768
-#define	YYNTBASE	16
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 261 ? yytranslate[x] : 19)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,    13,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,    14,
-    15,     9,     8,     2,     7,     2,    10,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,    12,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
-    11
-};
 
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     1,     4,     6,     9,    11,    13,    15,    17,    21,
-    25,    29,    33,    36
-};
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
 
-static const short yyrhs[] = {    -1,
-    16,    17,     0,    13,     0,    18,    13,     0,     3,     0,
-     4,     0,     5,     0,     6,     0,    18,     8,    18,     0,
-    18,     7,    18,     0,    18,     9,    18,     0,    18,    10,
-    18,     0,     7,    18,     0,    14,    18,    15,     0
-};
 
+/* Copy the second part of user declarations.  */
+
+
+/* Line 264 of yacc.c  */
+#line 171 "y.tab.c"
+
+#ifdef short
+# undef short
 #endif
 
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-    51,    52,    55,    56,    59,    63,    67,    71,    75,    79,
-    83,    87,    91,    95
-};
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
 #endif
 
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
 
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
 
-static const char * const yytname[] = {   "$","error","$undefined.","NUM","RAND",
-"RANK","PARAM","'-'","'+'","'*'","'/'","NEG","'^'","'\\n'","'('","')'","input",
-"line","exp", NULL
-};
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
 #endif
 
-static const short yyr1[] = {     0,
-    16,    16,    17,    17,    18,    18,    18,    18,    18,    18,
-    18,    18,    18,    18
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
 };
 
-static const short yyr2[] = {     0,
-     0,     2,     1,     2,     1,     1,     1,     1,     3,     3,
-     3,     3,     2,     3
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  2
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   36
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  16
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  4
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  15
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  24
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   262
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      13,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      14,    15,     9,     8,     2,     7,     2,    10,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,    12,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,    11
 };
 
-static const short yydefact[] = {     1,
-     0,     5,     6,     7,     8,     0,     3,     0,     2,     0,
-    13,     0,     0,     0,     0,     0,     4,    14,    10,     9,
-    11,    12,     0,     0
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     4,     7,     9,    12,    14,    16,    18,
+      20,    24,    28,    32,    36,    39
 };
 
-static const short yydefgoto[] = {     1,
-     9,    10
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      17,     0,    -1,    -1,    17,    18,    -1,    13,    -1,    19,
+      13,    -1,     3,    -1,     4,    -1,     5,    -1,     6,    -1,
+      19,     8,    19,    -1,    19,     7,    19,    -1,    19,     9,
+      19,    -1,    19,    10,    19,    -1,     7,    19,    -1,    14,
+      19,    15,    -1
 };
 
-static const short yypact[] = {-32768,
-     0,-32768,-32768,-32768,-32768,     5,-32768,     5,-32768,    23,
--32768,    19,     5,     5,     5,     5,-32768,-32768,    -8,    -8,
--32768,-32768,    16,-32768
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    53,    53,    54,    57,    58,    61,    65,    69,    73,
+      77,    81,    85,    89,    93,    97
 };
+#endif
 
-static const short yypgoto[] = {-32768,
--32768,     9
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "NUM", "RAND", "RANK", "PARAM", "'-'",
+  "'+'", "'*'", "'/'", "NEG", "'^'", "'\\n'", "'('", "')'", "$accept",
+  "input", "line", "exp", 0
 };
+#endif
 
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,    45,    43,    42,
+      47,   262,    94,    10,    40,    41
+};
+# endif
 
-#define	YYLAST		36
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    16,    17,    17,    18,    18,    19,    19,    19,    19,
+      19,    19,    19,    19,    19,    19
+};
 
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     2,     1,     2,     1,     1,     1,     1,
+       3,     3,     3,     3,     2,     3
+};
 
-static const short yytable[] = {    23,
-    15,    16,     2,     3,     4,     5,     6,     2,     3,     4,
-     5,     6,     7,     8,    11,    24,    12,     0,     8,     0,
-     0,    19,    20,    21,    22,    13,    14,    15,    16,    13,
-    14,    15,    16,    18,     0,    17
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     1,     6,     7,     8,     9,     0,     4,     0,
+       3,     0,    14,     0,     0,     0,     0,     0,     5,    15,
+      11,    10,    12,    13
 };
 
-static const short yycheck[] = {     0,
-     9,    10,     3,     4,     5,     6,     7,     3,     4,     5,
-     6,     7,    13,    14,     6,     0,     8,    -1,    14,    -1,
-    -1,    13,    14,    15,    16,     7,     8,     9,    10,     7,
-     8,     9,    10,    15,    -1,    13
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     1,    10,    11
 };
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/lib/bison.simple"
-/* This file comes from bison-1.28.  */
 
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -9
+static const yytype_int8 yypact[] =
+{
+      -9,     0,    -9,    -9,    -9,    -9,    -9,     5,    -9,     5,
+      -9,    23,    -9,    19,     5,     5,     5,     5,    -9,    -9,
+      -8,    -8,    -9,    -9
+};
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+      -9,    -9,    -9,     8
+};
 
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -1
+static const yytype_uint8 yytable[] =
+{
+       2,    16,    17,     3,     4,     5,     6,     7,     3,     4,
+       5,     6,     7,     8,     9,    12,     0,    13,     0,     9,
+       0,     0,    20,    21,    22,    23,    14,    15,    16,    17,
+      14,    15,    16,    17,    19,     0,    18
+};
 
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
-
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
-#endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
+static const yytype_int8 yycheck[] =
+{
+       0,     9,    10,     3,     4,     5,     6,     7,     3,     4,
+       5,     6,     7,    13,    14,     7,    -1,     9,    -1,    14,
+      -1,    -1,    14,    15,    16,    17,     7,     8,     9,    10,
+       7,     8,     9,    10,    15,    -1,    13
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    17,     0,     3,     4,     5,     6,     7,    13,    14,
+      18,    19,    19,    19,     7,     8,     9,    10,    13,    15,
+      19,    19,    19,    19
+};
 
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
+#define YYEMPTY		(-2)
 #define YYEOF		0
+
 #define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
    Once GCC version 2 has supplanted version 1, this can go.  */
+
 #define YYFAIL		goto yyerrlab
+
 #define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
+
+#define YYBACKUP(Token, Value)					\
 do								\
   if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
-while (0)
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-#ifndef YYPURE
-#define YYLEX		yylex()
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
 #endif
-#else /* not YYLSP_NEEDED */
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
 #ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
+# define YYLEX yylex (YYLEX_PARAM)
 #else
-#define YYLEX		yylex(&yylval)
+# define YYLEX yylex ()
 #endif
-#endif /* not YYLSP_NEEDED */
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
 #endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
 
-/* If nonreentrant, generate the variables here */
 
-#ifndef YYPURE
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
 
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
 
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
 #endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
 
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
 
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
 #endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
 
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
 
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
 #ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
+# define YYINITDEPTH 200
 #endif
 
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
 
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
-#endif
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
 
 #ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
+# define YYMAXDEPTH 10000
 #endif
+
 
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
 
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
+#if YYERROR_VERBOSE
 
-  while (i-- > 0)
-    *t++ = *f++;
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
 }
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
-#else /* __cplusplus */
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
 
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, unsigned int count)
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
 {
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
 
-  while (i-- > 0)
-    *t++ = *f++;
+  return yystpcpy (yyres, yystr) - yyres;
 }
+# endif
 
-#endif
-#endif
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
 
-#line 217 "/usr/lib/bison.simple"
 
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
 
-#ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
 
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
 #ifdef YYPARSE_PARAM
-int yyparse (void *);
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
 #else
-int yyparse (void);
+int yyparse ();
 #endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
 #endif
+#endif /* ! YYPARSE_PARAM */
 
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
 
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+/* The lookahead symbol.  */
+int yychar;
 
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
 
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
+/* Number of syntax errors so far.  */
+int yynerrs;
 
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
 #else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
 #endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
 
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
-
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
 #endif
 #endif
+{
 
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
 
-  int yylen;
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
+  YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
+  yychar = YYEMPTY; /* Cause a token to be read.  */
 
   /* Initialize stack pointers.
      Waste one element of value and location stack
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
-
-  yyssp = yyss - 1;
+  yyssp = yyss;
   yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
 
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
+  goto yysetstate;
 
-  *++yyssp = yystate;
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
 
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
+ yysetstate:
+  *yyssp = yystate;
 
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
       /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
+      YYSIZE_T yysize = yyssp - yyss + 1;
 
 #ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
 #else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
       /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
       yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
+      if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
 #endif /* no yyoverflow */
 
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
 
-      if (yyssp >= yyss + yystacksize - 1)
+      if (yyss + yystacksize - 1 <= yyssp)
 	YYABORT;
     }
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
 
   goto yybackup;
- yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
 
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to lookahead token.  */
   yyn = yypact[yystate];
-  if (yyn == YYFLAG)
+  if (yyn == YYPACT_NINF)
     goto yydefault;
 
   /* Not known => get a lookahead token if don't already have one.  */
 
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
   if (yychar == YYEMPTY)
     {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
+      YYDPRINTF ((stderr, "Reading a token: "));
       yychar = YYLEX;
     }
 
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
+  if (yychar <= YYEOF)
     {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
   else
     {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     goto yydefault;
-
   yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
+  if (yyn <= 0)
     {
-      if (yyn == YYFLAG)
+      if (yyn == 0 || yyn == YYTABLE_NINF)
 	goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
-  else if (yyn == 0)
-    goto yyerrlab;
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
 
   /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
 
+  yystate = yyn;
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
 
-  yystate = yyn;
   goto yynewstate;
 
-/* Do the default action for the current state.  */
-yydefault:
 
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
+  goto yyreduce;
 
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
 yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
   yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
 
-#if YYDEBUG != 0
-  if (yydebug)
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
     {
-      int i;
+        case 5:
 
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
+/* Line 1455 of yacc.c  */
+#line 58 "calc.yy"
+    { formula = f((yyvsp[(1) - (2)])); return 0; }
+    break;
 
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
+  case 6:
 
+/* Line 1455 of yacc.c  */
+#line 61 "calc.yy"
+    {
+	        (yyval) = formulas.size();
+	        formulas.push_back(new CalcFormula(new CalcNumber((yyvsp[(1) - (1)]))));
+        }
+    break;
 
-  switch (yyn) {
+  case 7:
 
-case 4:
-#line 56 "calc.yy"
-{ formula = f(yyvsp[-1]); return 0; ;
-    break;}
-case 5:
-#line 59 "calc.yy"
-{
-	        yyval = formulas.size();
-	        formulas.push_back(new CalcFormula(new CalcNumber(yyvsp[0])));
-        ;
-    break;}
-case 6:
-#line 63 "calc.yy"
-{
-	        yyval = formulas.size();
+/* Line 1455 of yacc.c  */
+#line 65 "calc.yy"
+    {
+	        (yyval) = formulas.size();
             formulas.push_back(new CalcFormula(new CalcRandom()));
-        ;
-    break;}
-case 7:
-#line 67 "calc.yy"
-{
-			yyval = formulas.size();
-			formulas.push_back(new CalcFormula(new CalcRank()));
-		;
-    break;}
-case 8:
-#line 71 "calc.yy"
-{
-			yyval = formulas.size();
-			formulas.push_back(new CalcFormula(new CalcParam(paramId)));
-		;
-    break;}
-case 9:
-#line 75 "calc.yy"
-{
-		    yyval = formulas.size();
-			formulas.push_back(new CalcFormula(f(yyvsp[-2]), op_add, f(yyvsp[0])));
-		;
-    break;}
-case 10:
-#line 79 "calc.yy"
-{
-		    yyval = formulas.size();
-			formulas.push_back(new CalcFormula(f(yyvsp[-2]), op_sub, f(yyvsp[0])));
-		;
-    break;}
-case 11:
-#line 83 "calc.yy"
-{
-		    yyval = formulas.size();
-			formulas.push_back(new CalcFormula(f(yyvsp[-2]), op_mul, f(yyvsp[0])));
-		;
-    break;}
-case 12:
-#line 87 "calc.yy"
-{
-		    yyval = formulas.size();
-			formulas.push_back(new CalcFormula(f(yyvsp[-2]), op_div, f(yyvsp[0])));
-		;
-    break;}
-case 13:
-#line 91 "calc.yy"
-{
-		    yyval = yyvsp[0];
-			f(yyvsp[0])->setHeadSub();
-		;
-    break;}
-case 14:
-#line 95 "calc.yy"
-{
-		    yyval = yyvsp[-1];
-		;
-    break;}
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 543 "/usr/lib/bison.simple"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
+        }
+    break;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
+  case 8:
 
-  *++yyvsp = yyval;
+/* Line 1455 of yacc.c  */
+#line 69 "calc.yy"
+    {
+			(yyval) = formulas.size();
+			formulas.push_back(new CalcFormula(new CalcRank()));
+		}
+    break;
 
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
+  case 9:
+
+/* Line 1455 of yacc.c  */
+#line 73 "calc.yy"
     {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
+			(yyval) = formulas.size();
+			formulas.push_back(new CalcFormula(new CalcParam(paramId)));
+		}
+    break;
 
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
+  case 10:
 
-  yyn = yyr1[yyn];
+/* Line 1455 of yacc.c  */
+#line 77 "calc.yy"
+    {
+		    (yyval) = formulas.size();
+			formulas.push_back(new CalcFormula(f((yyvsp[(1) - (3)])), op_add, f((yyvsp[(3) - (3)]))));
+		}
+    break;
 
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
+  case 11:
 
-  goto yynewstate;
+/* Line 1455 of yacc.c  */
+#line 81 "calc.yy"
+    {
+		    (yyval) = formulas.size();
+			formulas.push_back(new CalcFormula(f((yyvsp[(1) - (3)])), op_sub, f((yyvsp[(3) - (3)]))));
+		}
+    break;
 
-yyerrlab:   /* here on detecting error */
+  case 12:
 
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
+/* Line 1455 of yacc.c  */
+#line 85 "calc.yy"
     {
-      ++yynerrs;
+		    (yyval) = formulas.size();
+			formulas.push_back(new CalcFormula(f((yyvsp[(1) - (3)])), op_mul, f((yyvsp[(3) - (3)]))));
+		}
+    break;
 
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
+  case 13:
 
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
-	    {
-	      strcpy(msg, "parse error");
+/* Line 1455 of yacc.c  */
+#line 89 "calc.yy"
+    {
+		    (yyval) = formulas.size();
+			formulas.push_back(new CalcFormula(f((yyvsp[(1) - (3)])), op_div, f((yyvsp[(3) - (3)]))));
+		}
+    break;
 
-	      if (count < 5)
-		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
-		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
-		      }
+  case 14:
+
+/* Line 1455 of yacc.c  */
+#line 93 "calc.yy"
+    {
+		    (yyval) = (yyvsp[(2) - (2)]);
+			f((yyvsp[(2) - (2)]))->setHeadSub();
 		}
-	      yyerror(msg);
-	      free(msg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exceeded");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
-    }
+    break;
 
-  goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
+  case 15:
 
-  if (yyerrstatus == 3)
+/* Line 1455 of yacc.c  */
+#line 97 "calc.yy"
     {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+		    (yyval) = (yyvsp[(2) - (3)]);
+		}
+    break;
 
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
 
-      yychar = YYEMPTY;
+/* Line 1455 of yacc.c  */
+#line 1477 "y.tab.c"
+      default: break;
     }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
 
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
+  *++yyvsp = yyval;
 
-  goto yyerrhandle;
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
 
-yyerrdefault:  /* current state does not do anything special for the error token. */
+  yyn = yyr1[yyn];
 
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
 
-yyerrpop:   /* pop the current state because it cannot handle the error token */
 
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
 #endif
+    }
 
-#if YYDEBUG != 0
-  if (yydebug)
+
+
+  if (yyerrstatus == 3)
     {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
     }
-#endif
 
-yyerrhandle:
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
 
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
 
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
 
-  yyn = yytable[yyn];
-  if (yyn < 0)
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
     {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrpop;
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
 
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
 
   yystate = yyn;
   goto yynewstate;
 
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
 
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
     }
-  return 1;
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
-#line 99 "calc.yy"
+
+
+
+/* Line 1675 of yacc.c  */
+#line 101 "calc.yy"
 
 
 /**
- * 字句解析器は、数値を読めば、double型の値をスタックに積んで
- * トークン「NUM」を返し、数値以外を読めば、その文字のアスキー符号を返す。
- * 空白とタブは読み飛ばされる。ファイルが終わると0を返す。
+ * ｻｶ邊ﾀﾏｴ､ﾏ｡｢ｿﾃﾍ､ﾆﾉ､皃ﾐ｡｢doubleｷｿ､ﾎﾃﾍ､･ｹ･ｿ･ﾃ･ｯ､ﾋﾀﾑ､､ﾇ
+ * ･ﾈ｡ｼ･ｯ･｡ﾖNUM｡ﾗ､ﾊﾖ､ｷ｡｢ｿﾃﾍｰﾊｳｰ､ﾆﾉ､皃ﾐ｡｢､ｽ､ﾎﾊｸｻ､ﾎ･｢･ｹ･ｭ｡ｼﾉ荵讀ﾊﾖ､ｹ｡｣
+ * ｶﾇ､ﾈ･ｿ･ﾖ､ﾏﾆﾉ､ﾟﾈ､ﾐ､ｵ､､｡｣･ﾕ･｡･､･､ｬｽｪ､､､ﾈ0､ﾊﾖ､ｹ｡｣
  */
 
 #include <ctype.h>
@@ -1029,19 +1701,19 @@
 {
 	int c;
 
-	/* 空白類を読み飛ばす  */
+	/* ｶﾇﾎ爨ﾆﾉ､ﾟﾈ､ﾐ､ｹ  */
 	while ((c = *(yyinStr++)) == ' ' || c == '\t')
 		;
-	/* 数値を処理する   */
+	/* ｿﾃﾍ､ｽ靉､ｹ､   */
 	if (c == '.' || isdigit (c))
     {
 		yyinStr--;
-		sscanf (yyinStr, "%lf", &yylval);
+		sscanf (yyinStr, "%f", &yylval);
 		while ((c = *(++yyinStr)) == '.' || isdigit(c)) {}
 		return NUM;
     }
 
-	// 変数を処理する */
+	// ﾊﾑｿ､ｽ靉､ｹ､ */
 	if (c == '$') {
 		if (strncmp(yyinStr, "rand", 4) == 0) {
 			yyinStr += 4;
@@ -1059,10 +1731,10 @@
 		}
 	}
 
-	/* ファイルの終わりを処理する  */
+	/* ･ﾕ･｡･､･､ﾎｽｪ､､熙ｽ靉､ｹ､  */
 	if (c == '\0')
 		return 0;
-	/* 1文字を返す */
+	/* 1ﾊｸｻ､ﾊﾖ､ｹ */
 	return c;
 }
 
@@ -1078,3 +1750,4 @@
 	return std::auto_ptr<CalcFormula>(formula);
 }
 
+
diff -Naur src/calc.h src/calc.h
--- src/calc.h	2003-09-06 19:18:42.000000000 +0200
+++ src/calc.h	2010-11-25 09:35:35.667628996 +0100
@@ -7,7 +7,7 @@
 #include <string>
 #include <memory>
 
-DECLSPEC std::auto_ptr<Formula<double> > calc(const std::string& str);
+DECLSPEC std::auto_ptr<Formula<float> > calc(const std::string& str);
 
 #endif // CALC_H_
 
diff -Naur src/calc.yy src/calc.yy
--- src/calc.yy	2003-08-06 20:40:08.000000000 +0200
+++ src/calc.yy	2010-11-25 09:49:18.397628994 +0100
@@ -1,11 +1,13 @@
 /* ﾃ豢ﾖｵｭﾋ｡ﾅﾅﾂ -- calc */
 
 %{
-typedef double NumType;
+typedef float NumType;
 
-#define YYSTYPE double
+#define YYSTYPE float
 #define YYERROR_VERBOSE
 
+#include <string.h>
+
 #include <cmath>
 #include <cctype>
 
@@ -32,7 +34,7 @@
 	CalcFormula* formula;
 	std::vector<CalcFormula*> formulas;
 
-	CalcFormula* f(double d) { return formulas[(int)d]; }
+	CalcFormula* f(float d) { return formulas[(int)d]; }
 
 	int paramId;
 }
@@ -118,7 +120,7 @@
 	if (c == '.' || isdigit (c))
     {
 		yyinStr--;
-		sscanf (yyinStr, "%lf", &yylval);
+		sscanf (yyinStr, "%f", &yylval);
 		while ((c = *(++yyinStr)) == '.' || isdigit(c)) {}
 		return NUM;
     }
diff -Naur src/formula-variables.cpp formula-variables.cpp
--- src/formula-variables.cpp	2003-09-06 19:18:41.000000000 +0200
+++ src/formula-variables.cpp	2010-11-25 09:36:39.697628998 +0100
@@ -1,7 +1,7 @@
 #include "formula-variables.h"
 
 namespace Variables {
-	double rank;
-	std::vector<double>* parameters;
+	float rank;
+	std::vector<float>* parameters;
 	BulletMLRunner* runner;
 }
diff -Naur src/formula-variables.h src/formula-variables.h
--- src/formula-variables.h	2003-09-06 19:18:42.000000000 +0200
+++ src/formula-variables.h	2010-11-25 09:37:00.627628996 +0100
@@ -9,8 +9,8 @@
 #include <vector>
 
 namespace Variables {
-	DECLSPEC extern double rank;
-	DECLSPEC extern std::vector<double>* parameters;
+	DECLSPEC extern float rank;
+	DECLSPEC extern std::vector<float>* parameters;
 	DECLSPEC extern BulletMLRunner* runner;
 }
 
diff -Naur src/Makefile src/Makefile
--- src/Makefile	2003-08-08 22:36:24.000000000 +0200
+++ src/Makefile	2010-11-25 09:50:44.777628997 +0100
@@ -1,21 +1,19 @@
-CC = g++
+CC = psp-g++
+AR = psp-ar
 INCLUDES = -I.
-LIBS = tinyxml/tinyxml.o tinyxml/tinyxmlparser.o tinyxml/tinyxmlerror.o
 #CXXFLAGS = -g -W -Wall -ansi -pedantic
 #CXXFLAGS = -pg -g -W -Wall -ansi -pedantic
-CXXFLAGS = -O2 -W -Wall -ansi -pedantic
-CFLAGS = -O2
+CXXFLAGS = -O2 -W -Wall -ansi -pedantic -G0 -fsingle-precision-constant -fno-exceptions
+CFLAGS = -O2 -G0 -fsingle-precision-constant
 OBJS = bulletmlparser-tinyxml.o bulletmlparser.o bulletmltree.o calc.o formula-variables.o bulletmlrunner.o bulletmlrunnerimpl.o
 
 all: libbulletml.a
 
 libbulletml.a: $(OBJS)
-	$(MAKE) -C tinyxml
-	$(AR) -r libbulletml.a *.o tinyxml/tiny*.o
+	$(AR) -r libbulletml.a $(OBJS)
 
 clean:
 	rm -f *.o *.a
-	$(MAKE) -C tinyxml clean
 
 calc.cpp: calc.yy
 	bison -y   calc.yy && mv y.tab.c calc.cpp
@@ -27,4 +25,3 @@
 	doxygen
 
 distdir:
-
